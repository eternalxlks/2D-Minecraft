<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2D Minecraft with Mobile Controls</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
    canvas {
      display: block;
      background-color: #87CEEB;
    }
    .controls {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 100;
    }
    .mobile-controls {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      justify-content: space-between;
      width: 300px;
      z-index: 100;
    }
    .controls button, .controls select, .mobile-controls button {
      width: 60px;
      height: 60px;
      font-size: 18px;
      border: none;
      border-radius: 8px;
      background-color: #333;
      color: white;
      cursor: pointer;
    }
    .controls select {
      width: auto;
      padding: 5px;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div class="controls">
    <select id="blockType">
      <option value="1">Dirt</option>
      <option value="2">Stone</option>
      <option value="3">Grass</option>
    </select>
    <button id="build">üõ†Ô∏è Build</button>
  </div>
  <div class="mobile-controls">
    <button id="left">‚¨ÖÔ∏è</button>
    <button id="jump">‚¨ÜÔ∏è</button>
    <button id="right">‚û°Ô∏è</button>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const tileSize = 40;
    let tilesX = Math.ceil(canvas.width / tileSize);
    let tilesY = Math.ceil(canvas.height / tileSize);

    let world = Array(tilesY).fill().map((_, y) =>
      Array(tilesX).fill(y > tilesY / 2 ? 1 : 0)
    );

    const player = {
      x: Math.floor(tilesX / 2),
      y: Math.floor(tilesY / 2 - 2),
      dx: 0,
      dy: 0,
      size: 1,
      onGround: false,
      facing: 1, // 1 = right, -1 = left
    };

    const gravity = 0.2;
    const jumpStrength = -5;
    const speed = 0.1;

    const blockTypes = {
      1: '#654321', // Dirt
      2: '#808080', // Stone
      3: '#228B22', // Grass
    };

    let keys = {};
    let mobileControls = { left: false, right: false, jump: false };

    function drawWorld() {
      for (let y = 0; y < tilesY; y++) {
        for (let x = 0; x < tilesX; x++) {
          ctx.fillStyle = world[y][x] > 0 ? blockTypes[world[y][x]] : '#87CEEB';
          ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
        }
      }
    }

    function drawPlayer() {
      ctx.fillStyle = 'red';
      ctx.fillRect(player.x * tileSize, player.y * tileSize, tileSize, tileSize);
    }

    function updatePlayer() {
      // Apply gravity
      player.dy += gravity;

      // Horizontal movement
      player.x += player.dx;

      // Vertical movement
      player.y += player.dy;

      // Collision detection (ground)
      const leftTile = Math.floor(player.x);
      const rightTile = Math.floor(player.x + player.size);
      const bottomTile = Math.floor(player.y + player.size);

      if (
        (world[bottomTile] && world[bottomTile][leftTile] > 0) ||
        (world[bottomTile] && world[bottomTile][rightTile] > 0)
      ) {
        player.y = Math.floor(player.y);
        player.dy = 0;
        player.onGround = true;
      } else {
        player.onGround = false;
      }

      // Prevent out-of-bounds movement
      player.x = Math.max(0, Math.min(player.x, tilesX - player.size));
      player.y = Math.min(player.y, tilesY - player.size);
    }

    function handleMovement() {
      if (keys['ArrowLeft'] || keys['a'] || mobileControls.left) {
        player.dx = -speed;
        player.facing = -1;
      } else if (keys['ArrowRight'] || keys['d'] || mobileControls.right) {
        player.dx = speed;
        player.facing = 1;
      } else {
        player.dx = 0;
      }

      if (
        (keys['ArrowUp'] || keys[' '] || keys['w'] || mobileControls.jump) &&
        player.onGround
      ) {
        player.dy = jumpStrength;
      }
    }

    function placeBlock() {
      const blockType = parseInt(document.getElementById('blockType').value);
      const targetX = Math.floor(player.x + player.facing);
      const targetY = Math.floor(player.y + player.size - 1);

      if (
        targetX >= 0 &&
        targetX < tilesX &&
        targetY >= 0 &&
        targetY < tilesY &&
        world[targetY][targetX] === 0
      ) {
        world[targetY][targetX] = blockType;
      }
    }

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawWorld();
      drawPlayer();
      handleMovement();
      updatePlayer();
      requestAnimationFrame(gameLoop);
    }

    window.addEventListener('keydown', (e) => (keys[e.key] = true));
    window.addEventListener('keyup', (e) => (keys[e.key] = false));

    document.getElementById('left').addEventListener('mousedown', () => (mobileControls.left = true));
    document.getElementById('left').addEventListener('mouseup', () => (mobileControls.left = false));
    document.getElementById('right').addEventListener('mousedown', () => (mobileControls.right = true));
    document.getElementById('right').addEventListener('mouseup', () => (mobileControls.right = false));
    document.getElementById('jump').addEventListener('mousedown', () => (mobileControls.jump = true));
    document.getElementById('jump').addEventListener('mouseup', () => (mobileControls.jump = false));

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      tilesX = Math.ceil(canvas.width / tileSize);
      tilesY = Math.ceil(canvas.height / tileSize);
    });

    document.getElementById('build').addEventListener('click', placeBlock);

    gameLoop();
  </script>
</body>
</html>
